// Константы
package main

import "fmt"

func main() {
	const days int = 7 // типизированная константа. Программа компилируется даже без использования константы

	// константа при обьявлении инициализируется значением!
	const str string = "String"

	fmt.Println(days, str)

	// constants относится ко времени компиляции
	// переменные относятся ко времени выполнения (runtime)
	//x, y := 14, 0
	//fmt.Println(x / y) // компилятор в это время не видит ошибки деления на ноль!
	// ошибка будет во время выполнения runtime!

	// В случае с консатнтами - ошибка будет выявлена на этапе компиляции!
	// const a, b = 10, 0
	const a = 10
	const b = 1
	fmt.Println(a / b) //  division by zero

	// множественное (блоковое) объявление constants
	const (
		c1   = 100
		str1 = "Hello"
		c2   = 108
		c4   // без явной инициализации константа c4 получает свой тип и значение из предидущей константы - 108
	)
	fmt.Println(c1, str, c2, c4)

	/* ПРАВИЛА КОНСТАНТ

	1. Значение контанты нельзя изменить

	const temp = 100
	temp = 50 // ошибка на этапе компиляции

	2. Константе нельзя инициализировать во время выполнения runtime

	const c = math.Pow(4, 7) // Ошибка. Вызовы внешних функций - это область времени выполнения, а не компиляции

	3. Нельзя использовать переменную для инициализации константы По той же причине!

	v := 10
	const v // Ошибка.Переменные принадлежат времени выполнения runtime, а контанты - времени компиляции

	4. Можно использовать в инициализации встроенную функцию len("string literal"). Она встроенная,
	   относится ко времени компиляции!

	const c = len("Hello!") // нет ошибки.
	*/

	// Типы констант
	const ab float64 = 10.4 // типизированная константа. При обьявлении указан ее тип!
	const bc = 5.8          // нетипизированная константа

	// Выражения при инициализации констант разрешены в Go.
	const r float64 = a * b
	const sc = "Hello" + " " + "Go!"
	const ds = 5 > 10 // false
	fmt.Printf("%.2f : %.2f\t %.2f\t%s %t\n", ab, bc, r, sc, ds)

	const e = 4           // Нетипизированная const. Type int - неявный тип. Не попадает под строгие правил типизации
	const w = 3.4 * e     // для нетипизированных констант такие операции возможны, для типов int & float
	fmt.Printf("%T\n", w) // type float64

	var k1 = e         // Неявный тип const e при использовании выводится компиляором в явный!
	var k2 float64 = e // var k2 float64 = float64(x)
	fmt.Println(e, k1, k2)
	
}
