// Углубленное изучение map, хеш - таблиц, словарей и т.п.
package main

import "fmt"

func main() {
	// Map - струтура данных в виде набора пар "ключ: значение".
	// 1. Объявление
	// var m map[string]string  Мапа - ссылочный тип, поэтому одного обьявления недостаточно!
	// m["foo"] = "bar"         Ошибка. Паника в runtime. panic: assignment to entry in nil map!

	// 1.1 Переменные типа map инициализируются с помощью функции make!
	// встроенная функция make - это конструктор для обьектов ссылочного типа.
	type myMap map[string]int
	var m myMap
	m = make(myMap, 5)
	m["bar"] = 44
	fmt.Printf("Значение: %v Тип: %T Длинна: %d\n", m, m, len(m))

	// более компактный пример (внутри функции main)
	m1 := make(map[string]string)
	m1["Hi"] = "Mark"
	m1["lastName"] = "Sshvarchold"
	fmt.Printf("Значение: %v Тип: %T Длинна: %d\n", m1, m1, len(m1))

	// 2. Обьявление и инициализация с помощью композитного литерала {val, val1, val2,...}
	// в таком случае комопозитный литерал создает map без функции make и инициализирует пары "ключ: значение"!
	m2 := map[int]string{1: "A", 2: "B", 3: "C"}
	fmt.Printf("Значение: %v Тип: %T Длинна: %d\n", m2, m2, len(m2))

	// 3. В map ключ НЕ МОЖЕТ БЫТЬ ФУНКЦИЕЙ, ХЕШ-ТАБЛИЦЕЙ ИЛИ СРЕЗОМ (СЛАЙСОМ)!!!
	// а тип значений МОЖЕТ БЫТЬ ЛЮБЫМ!
	// Мапа НЕ УПОРЯДОЧЕНА В Go.
	// 3.1 Ключом в map (мапе) может быть ТОЛЬКО СРАВНИМЫ ТИП (==. !=).

	// 4. Получить адрес в памяти типа map НЕ ПОЛУЧИТСЯ! adrr := &m[key] - ошибка!

	// 5. Встроенная функция len() - возвращает длину map[k]v
	var m3 map[string]int
	if m != nil {
		m["age"] = 44
	}
	m4 := map[int]int{
		0: 10,
		1: 20,
		3: 30,
		4: 40,
		5: 80,
	}
	fmt.Println(len(m3), len(m4)) // выдаст 0 для неинициализорованной map, длинна 5 - для m4

	//6. При обращении к map по ключу - возвращается 2 значения.
	employee := map[string]int{
		"Dan":  10,
		"Jhon": 20,
		"Lucy": 40,
	}
	if v, ok := employee["Di"]; ok {
		fmt.Println("Jhon есть в мапе. Его значение: ", v)
	} else {
		fmt.Println("Этого нет в этой мапе! Поэтому значение: ", v)
	}

	// 7. Прербор (итерация) по мапе
	for key, value := range employee {
		fmt.Printf("%s and id %d\n", key, value)
	}

}
