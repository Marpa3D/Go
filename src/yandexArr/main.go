// Яндекс Практикум. Массивы
package main

import (
	"fmt"
)

func main() {

	// Массив - это посследовательность фиксированной длинны из элементов одного типа. Статическая конструкция.
	// Элементы массива расположены в памяти один за другим, последовательно

	var lastWeek [8]int // Число в скобках - колличество элементов, литерал - тип элементов массива
	// Число элементов - это часть типа данных. [5]int и [8]int - это разные типы массивов

	fmt.Println("Array = ", lastWeek)

	// Инициализация и обьявление в одном месте
	var arr = [8]int{1, 3, 4, 8} // {values...} - это список инициализации
	fmt.Println(arr, len(arr))

	// Автоматическое выявление колличества элементов через список инициализации
	arrAuto := [...]uint8{2, 4, 6, 8, 10}
	fmt.Println(arrAuto, "Длинна массива = ", len(arrAuto))

	// Указание только нужных индексов и элементов в массиве
	weekArr := [...]int{7: 12, 2: 2, 4: 8}
	fmt.Println(weekArr, len(weekArr))

	// Обход значений массива
	weekTemp := [7]int{4, 2, 0, -1, 8, 18, 22}

	someIndex := 0

	for i := 0; i < len(weekTemp); i++ {
		someIndex += weekTemp[i]
	}
	fmt.Printf("Средняя температура за неделю = %dC\n", someIndex/len(weekTemp))

	// Обход значений массива через for range. Во время выполнения оператор range копируется во временную переменную
	// и уже она используется для обхода.
	res := 0
	for _, j := range weekTemp {
		res += j
	}
	fmt.Printf("Средняя температура за неделю через конструкцию for range = %dC\n", res/len(weekTemp))

	// Переменные массива можно присваивать друг другу, НО тип и колличество элементов должны совпадать!
	// При присваивании полностью копируется массив!

	// При передачи массива (или любого другого типа данных) в параметр функции также происходит
	// полное копирование значений массива в эту переменную аргумента функции. Это нужно учитывать.

	// Все это, при больших обьемах может сильно замедлять программу, поэтому применяйте указатели
	temp := 0
	for _, temp = range &weekTemp {
		temp = 0
	}
	fmt.Println("Array = ", weekTemp, temp)

}
